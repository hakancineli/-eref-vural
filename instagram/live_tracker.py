#!/usr/bin/env python3
"""
Canlƒ± Instagram Profil Takip Sistemi
"""

import time
import logging
import threading
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from config import Config
from database import DatabaseManager
from notification import NotificationManager

class LiveTracker:
    def __init__(self):
        self.config = Config()
        self.db = DatabaseManager()
        self.notifier = NotificationManager()
        self.driver = None
        self.wait = None
        self.is_running = False
        self.tracked_viewers = set()
        self.setup_logging()
    
    def setup_logging(self):
        """Logging ayarlarƒ±nƒ± yapƒ±landƒ±rƒ±r"""
        logging.basicConfig(
            level=getattr(logging, self.config.LOG_LEVEL),
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('live_tracker.log'),
                logging.StreamHandler()
            ]
        )
    
    def setup_driver(self):
        """Selenium WebDriver'ƒ± yapƒ±landƒ±rƒ±r"""
        try:
            chrome_options = Options()
            
            if self.config.BROWSER_HEADLESS:
                chrome_options.add_argument('--headless')
            
            chrome_options.add_argument('--no-sandbox')
            chrome_options.add_argument('--disable-dev-shm-usage')
            chrome_options.add_argument('--disable-blink-features=AutomationControlled')
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            chrome_options.add_experimental_option('useAutomationExtension', False)
            
            # User agent ayarla
            chrome_options.add_argument('--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36')
            
            self.driver = webdriver.Chrome(options=chrome_options)
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            
            self.wait = WebDriverWait(self.driver, self.config.BROWSER_TIMEOUT)
            self.driver.set_page_load_timeout(self.config.PAGE_LOAD_TIMEOUT)
            
            logging.info("Canlƒ± takip i√ßin WebDriver ba≈ülatƒ±ldƒ±")
            return True
            
        except Exception as e:
            logging.error(f"WebDriver ba≈ülatma hatasƒ±: {e}")
            return False
    
    def login_to_instagram(self):
        """Instagram'a giri≈ü yapar"""
        try:
            logging.info("Instagram'a giri≈ü yapƒ±lƒ±yor...")
            
            self.driver.get(self.config.INSTAGRAM_LOGIN_URL)
            time.sleep(3)
            
            # Kullanƒ±cƒ± adƒ± giri≈üi
            username_field = self.wait.until(
                EC.presence_of_element_located((By.NAME, "username"))
            )
            username_field.clear()
            username_field.send_keys(self.config.INSTAGRAM_USERNAME)
            
            # ≈ûifre giri≈üi
            password_field = self.driver.find_element(By.NAME, "password")
            password_field.clear()
            password_field.send_keys(self.config.INSTAGRAM_PASSWORD)
            
            # Giri≈ü butonu
            login_button = self.driver.find_element(By.XPATH, "//button[@type='submit']")
            login_button.click()
            
            # 2FA kontrol√º (eƒüer varsa)
            time.sleep(5)
            if "checkpoint" in self.driver.current_url:
                logging.warning("2FA doƒürulamasƒ± gerekli! Manuel olarak tamamlayƒ±n.")
                input("2FA doƒürulamasƒ±nƒ± tamamladƒ±ktan sonra Enter'a basƒ±n...")
            
            # Ana sayfaya y√∂nlendirme kontrol√º
            self.wait.until(
                EC.presence_of_element_located((By.XPATH, "//nav"))
            )
            
            logging.info("Instagram'a ba≈üarƒ±yla giri≈ü yapƒ±ldƒ±")
            return True
            
        except Exception as e:
            logging.error(f"Instagram giri≈ü hatasƒ±: {e}")
            return False
    
    def check_profile_views(self):
        """Profil g√∂r√ºnt√ºlemelerini kontrol eder"""
        try:
            # Profil sayfasƒ±na git
            profile_url = f"{self.config.INSTAGRAM_BASE_URL}{self.config.INSTAGRAM_USERNAME}/"
            self.driver.get(profile_url)
            time.sleep(3)
            
            # Sayfanƒ±n tamamen y√ºklenmesini bekle
            self.wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
            
            # Profil g√∂r√ºnt√ºleyenler butonunu bul - daha kapsamlƒ± arama
            try:
                # Farklƒ± XPath'leri dene
                xpath_selectors = [
                    "//a[contains(text(), 'Profil g√∂r√ºnt√ºleyenler')]",
                    "//a[contains(text(), 'profile views')]",
                    "//a[contains(text(), 'Profile views')]",
                    "//a[contains(@href, 'profile_views')]",
                    "//button[contains(text(), 'Profil g√∂r√ºnt√ºleyenler')]",
                    "//button[contains(text(), 'profile views')]",
                    "//div[contains(text(), 'Profil g√∂r√ºnt√ºleyenler')]//a",
                    "//div[contains(text(), 'profile views')]//a",
                    "//span[contains(text(), 'Profil g√∂r√ºnt√ºleyenler')]//parent::a",
                    "//span[contains(text(), 'profile views')]//parent::a",
                    "//div[contains(@class, 'profile-views')]//a",
                    "//div[contains(@class, 'profile_views')]//a"
                ]
                
                viewers_button = None
                for xpath in xpath_selectors:
                    try:
                        viewers_button = self.driver.find_element(By.XPATH, xpath)
                        if viewers_button and viewers_button.is_displayed():
                            print(f"‚úÖ Profil g√∂r√ºnt√ºleyenler butonu bulundu: {xpath}")
                            break
                    except:
                        continue
                
                if viewers_button:
                    # JavaScript ile tƒ±kla
                    self.driver.execute_script("arguments[0].click();", viewers_button)
                    time.sleep(3)
                else:
                    print("‚ö†Ô∏è Profil g√∂r√ºnt√ºleyenler butonu bulunamadƒ± - alternatif y√∂ntem kullanƒ±lƒ±yor")
                    return self.check_recent_activity()
                
                # G√∂r√ºnt√ºleyen elementlerini bul
                viewer_elements = self.driver.find_elements(
                    By.XPATH, "//div[@role='dialog']//a[@role='link']"
                )
                
                new_viewers = []
                for element in viewer_elements:
                    try:
                        href = element.get_attribute("href")
                        if href and '/p/' not in href and href != profile_url:
                            username = href.split("/")[-2]
                            if username and username not in self.tracked_viewers:
                                # Kullanƒ±cƒ± adƒ±nƒ± al
                                try:
                                    username_element = element.find_element(By.XPATH, ".//span[contains(@class, '_aacl')]")
                                    full_name = username_element.text if username_element else ""
                                except:
                                    full_name = ""
                                
                                new_viewers.append((username, full_name))
                                self.tracked_viewers.add(username)
                    except:
                        continue
                
                # Yeni g√∂r√ºnt√ºleyenleri veritabanƒ±na ekle
                for username, full_name in new_viewers:
                    self.db.add_profile_viewer(username, full_name)
                    logging.info(f"üî¥ YENƒ∞ PROFƒ∞L G√ñR√úNT√úLEYEN: {username}")
                    
                    # Bildirim g√∂nder
                    message = f"üëÅÔ∏è Yeni profil g√∂r√ºnt√ºleyen: {username}"
                    if full_name:
                        message += f" ({full_name})"
                    self.notifier.send_notification(message)
                
                return len(new_viewers)
                
            except Exception as e:
                logging.warning(f"Profil g√∂r√ºnt√ºleyenler kontrol√º: {e}")
                return 0
            
        except Exception as e:
            logging.error(f"Profil g√∂r√ºnt√ºleme kontrol√º hatasƒ±: {e}")
            return 0
    
    def check_recent_activity(self):
        """Son aktiviteleri kontrol eder (alternatif y√∂ntem)"""
        try:
            print("üîç Son aktiviteler kontrol ediliyor...")
            
            # Ana sayfaya git
            self.driver.get(self.config.INSTAGRAM_BASE_URL)
            time.sleep(3)
            
            # Bildirimler butonunu bul ve tƒ±kla
            try:
                notifications_button = self.driver.find_element(
                    By.XPATH, "//a[contains(@href, '/accounts/activity/') or contains(@aria-label, 'Activity')]"
                )
                notifications_button.click()
                time.sleep(2)
                print("‚úÖ Bildirimler sayfasƒ± a√ßƒ±ldƒ±")
            except:
                print("‚ö†Ô∏è Bildirimler butonu bulunamadƒ±")
                return 0
            
            # Son aktiviteleri kontrol et
            activity_elements = self.driver.find_elements(
                By.XPATH, "//div[contains(@class, 'activity') or contains(@class, 'notification') or contains(@class, 'feed')]//a"
            )
            
            new_activities = []
            for element in activity_elements:
                try:
                    href = element.get_attribute("href")
                    if href and '/p/' not in href and href != f"{self.config.INSTAGRAM_BASE_URL}{self.config.INSTAGRAM_USERNAME}/":
                        username = href.split("/")[-2]
                        if username and username not in self.tracked_viewers and username != self.config.INSTAGRAM_USERNAME:
                            # Kullanƒ±cƒ± adƒ±nƒ± al
                            try:
                                username_element = element.find_element(By.XPATH, ".//span[contains(@class, '_aacl')]")
                                full_name = username_element.text if username_element else ""
                            except:
                                full_name = ""
                            
                            new_activities.append((username, full_name))
                            self.tracked_viewers.add(username)
                            print(f"üîç Yeni aktivite tespit edildi: {username}")
                except:
                    continue
            
            # Yeni aktiviteleri veritabanƒ±na ekle
            for username, full_name in new_activities:
                self.db.add_profile_viewer(username, full_name)
                logging.info(f"üî¥ YENƒ∞ AKTƒ∞Vƒ∞TE: {username}")
                
                # Bildirim g√∂nder
                message = f"üëÅÔ∏è Yeni profil aktivitesi: {username}"
                if full_name:
                    message += f" ({full_name})"
                self.notifier.send_notification(message)
            
            return len(new_activities)
            
        except Exception as e:
            logging.error(f"Aktivite kontrol√º hatasƒ±: {e}")
            return 0
    
    def check_blocked_users(self):
        """Engellenen kullanƒ±cƒ±larƒ± kontrol eder"""
        try:
            # Takip√ßi listesini kontrol et
            followers = self.get_followers_list()
            
            blocked_count = 0
            for username, _ in followers:
                is_blocked = self.check_user_blocked_me(username)
                if is_blocked:
                    # Durumu g√ºncelle
                    self.db.update_block_status(username, True)
                    blocked_count += 1
                    logging.info(f"üî¥ YENƒ∞ ENGELLEYEN: {username}")
                    
                    # Bildirim g√∂nder
                    message = f"üö´ Sizi engelleyen kullanƒ±cƒ±: {username}"
                    self.notifier.send_notification(message)
                
                time.sleep(0.5)  # Rate limiting
            
            return blocked_count
            
        except Exception as e:
            logging.error(f"Engellenen kullanƒ±cƒ± kontrol√º hatasƒ±: {e}")
            return 0
    
    def get_followers_list(self):
        """Takip√ßi listesini alƒ±r"""
        try:
            # Profil sayfasƒ±na git
            profile_url = f"{self.config.INSTAGRAM_BASE_URL}{self.config.INSTAGRAM_USERNAME}/"
            self.driver.get(profile_url)
            time.sleep(2)
            
            # Takip√ßi sayƒ±sƒ±na tƒ±kla
            try:
                followers_link = self.driver.find_element(By.XPATH, "//a[contains(@href, '/followers/')]")
                self.driver.execute_script("arguments[0].click();", followers_link)
                time.sleep(2)
                
                followers = []
                follower_elements = self.driver.find_elements(
                    By.XPATH, "//div[@role='dialog']//a[@role='link']"
                )
                
                for element in follower_elements:
                    try:
                        href = element.get_attribute("href")
                        if href and '/p/' not in href and href != profile_url:
                            username = href.split("/")[-2]
                            if username:
                                followers.append((username, ""))
                    except:
                        continue
                
                return followers
                
            except Exception as e:
                logging.warning(f"Takip√ßi listesi alma hatasƒ±: {e}")
                return []
            
        except Exception as e:
            logging.error(f"Takip√ßi listesi hatasƒ±: {e}")
            return []
    
    def check_user_blocked_me(self, username):
        """Kullanƒ±cƒ±nƒ±n beni engelleyip engellemediƒüini kontrol eder"""
        try:
            user_profile_url = f"{self.config.INSTAGRAM_BASE_URL}{username}/"
            self.driver.get(user_profile_url)
            time.sleep(1)
            
            page_source = self.driver.page_source.lower()
            
            blocked_indicators = [
                "this page is not available",
                "user not found",
                "page not found",
                "kullanƒ±cƒ± bulunamadƒ±",
                "sayfa bulunamadƒ±",
                "sorry, this page isn't available",
                "√ºzg√ºn√ºz, bu sayfa mevcut deƒüil"
            ]
            
            for indicator in blocked_indicators:
                if indicator in page_source:
                    return True
            
            return False
            
        except Exception as e:
            logging.error(f"Engelleme kontrol√º hatasƒ± ({username}): {e}")
            return False
    
    def start_live_tracking(self):
        """Canlƒ± takibi ba≈ülatƒ±r"""
        try:
            logging.info("üöÄ Canlƒ± takip ba≈ülatƒ±lƒ±yor...")
            
            if not self.setup_driver():
                return False
            
            if not self.login_to_instagram():
                return False
            
            self.is_running = True
            print("‚úÖ Canlƒ± takip ba≈ülatƒ±ldƒ±! Profil g√∂r√ºnt√ºleyenler ve engellenen kullanƒ±cƒ±lar anƒ±nda tespit edilecek.")
            print("‚èπÔ∏è  Durdurmak i√ßin Ctrl+C tu≈ülayƒ±n.")
            
            while self.is_running:
                try:
                    # Profil g√∂r√ºnt√ºlemelerini kontrol et
                    new_viewers = self.check_profile_views()
                    if new_viewers > 0:
                        print(f"üëÅÔ∏è {new_viewers} yeni profil g√∂r√ºnt√ºleyen tespit edildi!")
                    
                    # Alternatif aktivite kontrol√º
                    if new_viewers == 0:
                        new_activities = self.check_recent_activity()
                        if new_activities > 0:
                            print(f"üëÅÔ∏è {new_activities} yeni aktivite tespit edildi!")
                    
                    # Engellenen kullanƒ±cƒ±larƒ± kontrol et
                    new_blocked = self.check_blocked_users()
                    if new_blocked > 0:
                        print(f"üö´ {new_blocked} yeni engelleyen kullanƒ±cƒ± tespit edildi!")
                    
                    # 30 saniye bekle
                    time.sleep(30)
                    
                except KeyboardInterrupt:
                    print("\n‚èπÔ∏è  Canlƒ± takip durduruluyor...")
                    self.is_running = False
                    break
                except Exception as e:
                    logging.error(f"Canlƒ± takip d√∂ng√ºs√º hatasƒ±: {e}")
                    time.sleep(60)  # Hata durumunda 1 dakika bekle
            
            return True
            
        except Exception as e:
            logging.error(f"Canlƒ± takip ba≈ülatma hatasƒ±: {e}")
            return False
        
        finally:
            if self.driver:
                self.driver.quit()
    
    def stop_live_tracking(self):
        """Canlƒ± takibi durdurur"""
        self.is_running = False
        logging.info("Canlƒ± takip durduruldu")

def main():
    """Ana fonksiyon"""
    tracker = LiveTracker()
    
    print("üî¥ CANLI INSTAGRAM TAKƒ∞P Sƒ∞STEMƒ∞")
    print("=" * 40)
    print("Bu sistem:")
    print("‚Ä¢ Profilinizi g√∂r√ºnt√ºleyen kullanƒ±cƒ±larƒ± anƒ±nda tespit eder")
    print("‚Ä¢ Sizi engelleyen kullanƒ±cƒ±larƒ± anƒ±nda tespit eder")
    print("‚Ä¢ Yeni aktiviteleri bildirim olarak g√∂nderir")
    print("=" * 40)
    
    try:
        tracker.start_live_tracking()
    except KeyboardInterrupt:
        print("\nüëã Canlƒ± takip sonlandƒ±rƒ±ldƒ±.")
    except Exception as e:
        print(f"‚ùå Hata: {e}")

if __name__ == "__main__":
    main() 